volatile 变量

Java给程序员提供的是happen-before抽象，我们开发时依赖happen-before抽象来保证程序的正确性。
volatile是实现多线程之间的这种抽象的用户接口。

使用volatile之后我们可以有以下两个可以确信虚拟机提供的保障
第一：
对volatile变量赋值之后的指令，即使是在其他线程看来，也都是发生在volatile指令之后
第二：
对volatile变量的赋值，其他线程一定可见。

举个例子：
Thread 1

int a = 0;
int b = 0;
a = 1;
b = 2;
print (a)
print (b)

Thread 2
print(a)
print (b)

根据happen before原则，在一个线程中，我们可以依赖指令的顺序来判断其执行顺序，
因此输出结果可以确定是
1
2

但是线程2中，由于编译期会有指令重排，CPU也会出现运行期的指令重排。
JVM只提供了单线程的指令的happen before保证，因此对于线程2，不一定输出结果是(0,0)或(1,0)或
(1,2),还有可能出现(2,1),原因就是可能因为指令重新排序导致 b=2指令运行在a=1之前，但这显然
不是人可预见的结果。因为我们通常都会认为写在前面的指令必然在前面执行。
为了保证在Thread 2中可以依赖
a = 1
b = 2
的执行顺序， 我们可以将a设置为volatile变量。JVM提供了一条volatile原则，对volatile变量的
赋值的指令，其之后的指令必然在此赋值之后(即使是其他的观察线程)。因此，将a设置为volatile之后，
在thread 2中的指令顺序也就必然是
a = 1
b = 2
也就保证了我们需要的happen-before顺序。
JVM另外提供的happen-before保证是
多个线程之间：Thread的方法： start,join,interrupt,调用者之前的指令happen 
before方法中执行或者检查的指令
对象构建： 构造方法中的指令执行在finalize 方法体之前
锁：解锁之前的指令发生之后加锁指令之前
传递性

volatile不能保证变量操作的原子性。

有时候我们会用原子性，可见性，有序性来说明volatile，并说volatile具备可见性和有序性。个人
觉得可见性是一个理解问题的方式，而不是一个分析问题的思路。可见性是这样描述的：一个线程修改
了变量之后，另一个线程能够立即得知这个变量的修改。这个描述看起来像是一个线程的修改会给另外
一个线程发通知，但实际上表达的含义是一个线程更改了一个变量之后，另一个线程再来读取，
必然不会读取到一个之前的指。它能促使我们的思考为一个一个线程会读到一个旧值，原因是CPU缓存的
存在导致线程不一定能读到最新的值。但在分析问题上，我们实际上无法知道一个线程是在什么时间去改
一个变量，另一个线程又是在什么时间需要知道这个变量的修改。所以，分析代码正确性的时候，采用
happen before的理解更为有效。





